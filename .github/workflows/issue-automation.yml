name: üé´ Issue Automation

on:
  issues:
    types: [opened, edited, closed, reopened]
  issue_comment:
    types: [created]
  pull_request:
    types: [opened, closed]

# Fix for 403 "Resource not accessible by integration" error
permissions:
  issues: write
  contents: read
  pull-requests: write

jobs:
  auto-label:
    name: üè∑Ô∏è Auto-assign Labels
    runs-on: ubuntu-latest
    if: github.event.action == 'opened' && github.event.issue
    
    steps:
    - name: üì• Checkout Repository
      uses: actions/checkout@v4
      
    - name: üè∑Ô∏è Auto-label based on title
      uses: actions/github-script@v7
      with:
        github-token: ${{secrets.GITHUB_TOKEN}}
        script: |
          const title = context.payload.issue.title.toLowerCase();
          const body = context.payload.issue.body?.toLowerCase() || '';
          const labels = [];
          
          // Priority labels based on content
          if (title.includes('critical') || body.includes('critical') || body.includes('üî¥ critical')) {
            labels.push('üî¥ critical');
          } else if (title.includes('high') || body.includes('high priority') || body.includes('üü° high')) {
            labels.push('üü° high');
          } else if (title.includes('low') || body.includes('low priority') || body.includes('‚ö™ low')) {
            labels.push('‚ö™ low');
          } else {
            labels.push('üü¢ medium');
          }
          
          // Component labels
          if (title.includes('deepseek') || body.includes('deepseek')) {
            labels.push('ü§ñ ai-deepseek');
          }
          if (title.includes('fmp') || title.includes('router') || body.includes('fmp')) {
            labels.push('üîó fmp-router');
          }
          if (title.includes('orchestrator') || body.includes('test orchestrator')) {
            labels.push('üß™ test-orchestrator');
          }
          
          // Environment labels
          if (body.includes('[x] dev') || body.includes('dev –æ–∫—Ä—É–∂–µ–Ω–∏–µ') || title.includes('dev')) {
            labels.push('üîÑ dev');
          }
          if (body.includes('[x] prod') || body.includes('prod –æ–∫—Ä—É–∂–µ–Ω–∏–µ') || title.includes('prod')) {
            labels.push('üöÄ prod');
          }
          
          console.log('Adding labels:', labels);
          
          if (labels.length > 0) {
            await github.rest.issues.addLabels({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              labels: labels
            });
          }

  template-validation:
    name: ‚úÖ Validate Issue Template
    runs-on: ubuntu-latest
    if: github.event.action == 'opened' && github.event.issue
    
    steps:
    - name: üîç Check Template Compliance
      uses: actions/github-script@v7
      with:
        github-token: ${{secrets.GITHUB_TOKEN}}
        script: |
          const title = context.payload.issue.title;
          const body = context.payload.issue.body || '';
          
          let warnings = [];
          let suggestions = [];
          
          // Check title format
          const titleFormats = ['[BUG]', '[FEATURE]', '[ENHANCEMENT]', '[DOCS]', '[TEST]'];
          const hasValidFormat = titleFormats.some(format => title.includes(format));
          
          if (!hasValidFormat) {
            warnings.push('–ó–∞–≥–æ–ª–æ–≤–æ–∫ –Ω–µ —Å–æ–¥–µ—Ä–∂–∏—Ç —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω—ã–π –ø—Ä–µ—Ñ–∏–∫—Å: ' + titleFormats.join(', '));
          }
          
          // Check for required sections in bug reports
          if (title.includes('[BUG]')) {
            if (!body.includes('## üîÑ –ó–∞—Ç—Ä–æ–Ω—É—Ç—ã–π workflow')) {
              warnings.push('Bug report –¥–æ–ª–∂–µ–Ω —Å–æ–¥–µ—Ä–∂–∞—Ç—å —Å–µ–∫—Ü–∏—é "–ó–∞—Ç—Ä–æ–Ω—É—Ç—ã–π workflow"');
            }
            if (!body.includes('## üìù –®–∞–≥–∏ –¥–ª—è –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏—è')) {
              warnings.push('Bug report –¥–æ–ª–∂–µ–Ω —Å–æ–¥–µ—Ä–∂–∞—Ç—å —Å–µ–∫—Ü–∏—é "–®–∞–≥–∏ –¥–ª—è –≤–æ—Å–ø—Ä–æ–∏–∑–≤–µ–¥–µ–Ω–∏—è"');
            }
          }
          
          // Check for required sections in feature requests
          if (title.includes('[FEATURE]')) {
            if (!body.includes('## üí° –ú–æ—Ç–∏–≤–∞—Ü–∏—è –∏ –∫–æ–Ω—Ç–µ–∫—Å—Ç')) {
              warnings.push('Feature request –¥–æ–ª–∂–µ–Ω —Å–æ–¥–µ—Ä–∂–∞—Ç—å —Å–µ–∫—Ü–∏—é "–ú–æ—Ç–∏–≤–∞—Ü–∏—è –∏ –∫–æ–Ω—Ç–µ–∫—Å—Ç"');
            }
            if (!body.includes('## üß™ –ö—Ä–∏—Ç–µ—Ä–∏–∏ –ø—Ä–∏–µ–º–∫–∏')) {
              warnings.push('Feature request –¥–æ–ª–∂–µ–Ω —Å–æ–¥–µ—Ä–∂–∞—Ç—å —Å–µ–∫—Ü–∏—é "–ö—Ä–∏—Ç–µ—Ä–∏–∏ –ø—Ä–∏–µ–º–∫–∏"');
            }
          }
          
          // Create comment if there are issues
          if (warnings.length > 0) {
            const comment = `## üìã –ü—Ä–æ–≤–µ—Ä–∫–∞ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤–∏—è —à–∞–±–ª–æ–Ω—É
            
          ‚ö†Ô∏è **–û–±–Ω–∞—Ä—É–∂–µ–Ω—ã –ø—Ä–æ–±–ª–µ–º—ã —Å —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ–º Issue:**
          
          ${warnings.map(w => `- ${w}`).join('\n')}
          
          üìñ **–†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏:**
          - –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ —à–∞–±–ª–æ–Ω—ã –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ Issues
          - –ó–∞–ø–æ–ª–Ω–∏—Ç–µ –≤—Å–µ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω—ã–µ —Å–µ–∫—Ü–∏–∏
          - –°–ª–µ–¥—É–π—Ç–µ [GitHub Issues Protocol](../blob/main/docs/github-issues-protocol.md)
          
          *–≠—Ç–æ—Ç –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π —Å–æ–∑–¥–∞–Ω –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏*`;
          
            await github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: comment
            });
          }

  milestone-assignment:
    name: üìÖ Auto-assign Milestones
    runs-on: ubuntu-latest
    if: github.event.action == 'opened' && github.event.issue
    
    steps:
    - name: üéØ Assign to Roadmap Milestone
      uses: actions/github-script@v7
      with:
        github-token: ${{secrets.GITHUB_TOKEN}}
        script: |
          const title = context.payload.issue.title.toLowerCase();
          const body = context.payload.issue.body?.toLowerCase() || '';
          const labels = context.payload.issue.labels.map(l => l.name);
          
          let milestone = null;
          
          // v1.1 - Testing Framework (highest priority)
          if (title.includes('test') || title.includes('orchestrator') || 
              body.includes('test orchestrator') || body.includes('execute workflow trigger') ||
              labels.some(l => l.includes('testing'))) {
            milestone = 'v1.1 - Testing Framework';
          }
          // v1.2 - Infrastructure & Automation  
          else if (title.includes('github action') || title.includes('automation') ||
                   title.includes('ci/cd') || title.includes('pipeline') ||
                   body.includes('github actions')) {
            milestone = 'v1.2 - Infrastructure & Automation';
          }
          // v1.3 - Advanced Features
          else if (title.includes('advanced') || title.includes('optimization') ||
                   title.includes('monitoring') || body.includes('enterprise')) {
            milestone = 'v1.3 - Advanced Features';
          }
          // Default to current milestone for high priority items
          else if (labels.some(l => l.includes('üî¥ critical') || l.includes('üü° high'))) {
            milestone = 'v1.1 - Testing Framework';
          }
          
          if (milestone) {
            console.log(`Assigning to milestone: ${milestone}`);
            
            // Note: This requires milestones to be created manually in GitHub first
            // The actual API call would need milestone numbers, not names
            const comment = `üéØ **Auto-assignment**: –≠—Ç–æ—Ç Issue –æ—Ç–Ω–æ—Å–∏—Ç—Å—è –∫ milestone **${milestone}**
            
          –°–æ–≥–ª–∞—Å–Ω–æ [Project Roadmap](../blob/main/docs/roadmap.md), —ç—Ç–∞ –∑–∞–¥–∞—á–∞ –∑–∞–ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–∞ –¥–ª—è —É–∫–∞–∑–∞–Ω–Ω–æ–≥–æ milestone.
          
          *Milestone –±—É–¥–µ—Ç –Ω–∞–∑–Ω–∞—á–µ–Ω –≤—Ä—É—á–Ω—É—é –ø–æ—Å–ª–µ —Å–æ–∑–¥–∞–Ω–∏—è –≤ GitHub Projects.*`;
          
            await github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: comment
            });
          }

  close-automation:
    name: üîÑ Handle Issue Closure
    runs-on: ubuntu-latest
    if: github.event.action == 'closed'
    
    steps:
    - name: üìä Update Project Metrics
      uses: actions/github-script@v7
      with:
        github-token: ${{secrets.GITHUB_TOKEN}}
        script: |
          const issue = context.payload.issue;
          
          // Create closure summary comment
          const comment = `## ‚úÖ Issue Closed
          
          **Closed at**: ${new Date().toISOString()}
          **Total comments**: ${issue.comments}
          **Labels**: ${issue.labels.map(l => l.name).join(', ') || 'None'}
          
          üìä **Impact**: –≠—Ç–æ—Ç Issue –±—ã–ª —á–∞—Å—Ç—å—é roadmap —Ä–∞–∑–≤–∏—Ç–∏—è –ø—Ä–æ–µ–∫—Ç–∞ n8n workflows.
          
          ---
          *–ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ —Å–æ–∑–¥–∞–Ω–æ –ø—Ä–∏ –∑–∞–∫—Ä—ã—Ç–∏–∏ Issue*`;
          
          await github.rest.issues.createComment({
            issue_number: context.issue.number,
            owner: context.repo.owner,
            repo: context.repo.repo,
            body: comment
          });
          
          console.log(`Issue #${issue.number} closed: ${issue.title}`);

  pr-link-issues:
    name: üîó Link PRs to Issues
    runs-on: ubuntu-latest
    if: github.event.pull_request && github.event.action == 'opened'
    
    steps:
    - name: üîç Find Related Issues
      uses: actions/github-script@v7
      with:
        github-token: ${{secrets.GITHUB_TOKEN}}
        script: |
          const pr = context.payload.pull_request;
          const body = pr.body?.toLowerCase() || '';
          const title = pr.title.toLowerCase();
          
          // Look for issue references in PR
          const issueRefs = [];
          const patterns = [
            /(?:close[sd]?|fix(?:e[sd])?|resolve[sd]?)\s*#(\d+)/gi,
            /#(\d+)/g
          ];
          
          patterns.forEach(pattern => {
            let match;
            while ((match = pattern.exec(body + ' ' + title)) !== null) {
              const issueNum = parseInt(match[1]);
              if (!issueRefs.includes(issueNum)) {
                issueRefs.push(issueNum);
              }
            }
          });
          
          if (issueRefs.length > 0) {
            const comment = `üîó **–°–≤—è–∑–∞–Ω–Ω—ã–µ Issues**: ${issueRefs.map(n => `#${n}`).join(', ')}
            
          –≠—Ç–æ—Ç Pull Request —Å–≤—è–∑–∞–Ω —Å —É–∫–∞–∑–∞–Ω–Ω—ã–º–∏ Issues. –ü–æ—Å–ª–µ merge —Å–≤—è–∑–∞–Ω–Ω—ã–µ Issues –±—É–¥—É—Ç –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –∑–∞–∫—Ä—ã—Ç—ã –µ—Å–ª–∏ –∏—Å–ø–æ–ª—å–∑—É—é—Ç—Å—è –∫–ª—é—á–µ–≤—ã–µ —Å–ª–æ–≤–∞ (closes, fixes, resolves).`;
          
            await github.rest.issues.createComment({
              issue_number: pr.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: comment
            });
          }